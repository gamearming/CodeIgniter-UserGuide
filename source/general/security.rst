########
安全
########

這篇文章將介紹一些基本的關於 Web 安全的 "最佳實踐" ，並詳細說明了 CodeIgniter
內部的安全特性。

.. note:: If you came here looking for a security contact, please refer to
	our `Contribution Guide <../contributing/index>`.

URI 安全
============

CodeIgniter 嚴格限制 URI 中允許出現的字元，以此來減少惡意資料傳到您的應用程式的可能性。
URI 中只允許包含一些字元：

-  字母和數字
-  波浪符：~
-  百分號：%
-  句號：.
-  分號：:
-  下劃線：\_
-  連字號：-
-  空格

Register_globals
================

在系統初始化期間，如果發現任何 ``$_GET``、``$_POST``、``$_REQUEST`` 和 ``$_COOKIE``
陣列中的鍵值變成了全區變數，則刪除該變數。

這個過程和設定 *register_globals = off* 效果是一樣的。
（譯註：閱讀這裡瞭解 `register_globals 設定 <http://php.net/manual/zh/security.globals.php>`_ ）

display_errors
==============

在生產環境下，一般都是通過將 *display_errors* 標誌設定為 0 來停用 PHP 的錯誤報告。
這可以阻止原生的 PHP 錯誤被顯示到頁面上，錯誤中可能會包含潛在的敏感資訊。

在 CodeIgniter 中，可以將 index.php 文件中的 **ENVIRONMENT** 常數設定為 **\'production\'** ，
這樣也可以關閉這些錯誤資訊。在開發模式下，建議將它設定為 'development' 。
關於不同環境之間的區別可以閱讀 :doc:`處理多環境 <environments>` 頁面瞭解更多。

magic_quotes_runtime
====================

在系統初始化期間， *magic_quotes_runtime* 指令會被停用，
這樣當您在從資料庫中讀取資料時就不用再去除反斜線了。

**************
最佳實踐
**************

在您的應用程式處理任何資料之前，無論這些資料是來自於送出的表單 POST ，還是來自
COOKIE、URI、XML-RPC ，或者甚至是來自於 SERVER 陣列，您都應該使用下面這三步
來處理：

#. 驗證資料類型是否正確，以及長度、大小等等
#. 過濾不良資料
#. 在送出到資料庫或者顯示到瀏覽器之前對資料進行轉義

CodeIgniter 提供了以下的成員函數和技巧來幫您處理該過程：

XSS 過濾
=============

CodeIgniter 自帶有一個 XSS 過濾器，這個過濾器可以查找一些 XSS 的常用技術，
例如向您的資料中嵌入惡意的 JavaScript 腳本，劫持 cookie 資訊或其他一些技術。
XSS 過濾器在 :doc:`這裡 <../libraries/security>` 有更詳細的描述。

.. note:: XSS 過濾 *只應該在輸出資料時使用* 。 對輸入的資料進行過濾可能會
	在無意中對資料造成修改，例如過濾密碼中的特殊字元，這樣會降低安全性，
	而不是提高安全性。

CSRF 保護
===============

CSRF（Cross-Site Request Forgery，跨站請求偽造）是攻擊者騙取受害者
在不知情的情況下送出請求的攻擊方式。

CodeIgniter 提供了對 CSRF 的保護，會在每個非 GET HTTP 請求時自動觸發，
當然前提是您要使用某種方式來建立表單，這在 :doc:`安全類 <../libraries/security>`
文件中有進一步的解釋。

密碼處理
=================

在您的應用程式中正確處理密碼是非常關鍵的。

但是不幸的是，許多開發者並不知道怎麼去做，而且網絡上充斥著大量過時的
甚至錯誤的建議，提供不了任何幫助。

我們提供了一個清單來幫助您，告訴您什麼該做，什麼不該做。

-  絕不要以明文儲存密碼。

   永遠使用 **哈希算法** 來處理密碼。

-  絕不要使用 Base64 或其他編碼方式來儲存密碼。

   這和以明文儲存密碼是一樣的，使用 **哈希** ，而不要使用 **編碼** 。

   編碼以及加密，都是雙向的過程，而密碼是保密的，應該只被它的所有者知道，
   這個過程必須是單向的。哈希正是用於做這個的，從來沒有解哈希這種說法，
   但是編碼就存在解碼，加密就存在解密。

-  絕不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 。

   這些算法太老了，而且被證明存在缺陷，它們一開始就並不是為了儲存密碼而設計的。

   另外，絕不要自己發明算法。

   只使用強密碼哈希算法，例如 BCrypt ，在 PHP 自己的 `密碼哈希 <http://php.net/password>`_
   函數中也是使用它。

   即使您的 PHP 版本不是 5.5+ ，也請使用它們，CodeIgniter 為您提供了這些算法。

   如果您連升級 PHP 也無法做到，那麼使用 `hash_pbkdf() <http://php.net/hash_pbkdf2>` 吧，
   為實現相容性我們提供了這個函數。

-  絕不要以明文形式顯示或發送密碼。

   即使是對密碼的所有者也應該這樣。如果您需要 "忘記密碼" 的功能，可以隨機產生一個新的
   一次性的（這點很重要）密碼，然後把這個密碼發送給用戶。

-  絕不要對用戶的密碼做一些沒必要的限制。

   如果您使用除 BCrypt（它有最多 72 字元的限制）之外的其他哈希算法，您應該設定一個相對長一點的密碼長度（例如 1024 字元），這樣可以緩解 DoS 攻擊。

   但是除此之外，對密碼的其他限制諸如密碼中只允許使用某些字元，或者密碼中不允許包含某些字元，就沒有任何意義了。

   這樣做不僅不會提高安全性，反而 **降低了** 安全性，而且真的沒有任何理由需要這樣做。
   只要您對密碼進行哈希處理了，那麼無論是技術上，還是在儲存上都沒有任何限制。

驗證輸入資料
===================

CodeIgniter 有一個 :doc:`表單驗證類 <../libraries/form_validation>` 用於幫助您驗證、
過濾以及預處理您的資料。

就算這個類不適用於您的使用場景，那麼您也應該確保對輸入資料進行驗證過濾。
例如，您希望接受一個數字型的參數，您可以使用  ``is_numeric()`` 或 ``ctype_digit()``
函數來檢查一下。永遠將資料限制在您執行的範圍內。

記住，不僅要驗證 ``$_POST`` 和 ``$_GET`` 變數，而且也不要放過 cookie 、user-agent
以及 **其他所有的不是直接由您的程式碼產生的資料** 。

插入資料庫之前對資料進行轉義
=========================================

永遠不要不做轉義就將資料插入到資料庫，更多資訊，可以閱讀 :doc:`資料庫查詢
<../database/queries>` 這一節。

隱藏您的文件
===============

另一個很好的安全實踐是，在您的 *webroot* 目錄（通常目錄名為 "htdocs/"）下只保留
*index.php* 文件和 "assets" 目錄（用於存放 js、css、圖片等靜態資源）。
只需要這些文件能從 Web 上存取就可以了。

允許您的存取者存取其他位置可能潛在的導致他們存取一些敏感資料或者執行腳本等等。

如果您不允許這樣做，您可以使用 .htaccess 文件來限制對這些資源的存取。

CodeIgniter 在每個目錄下放置了一個 index.html 文件，試圖隱藏這些敏感資料，但是要記住的是，這對於防止一個真正的攻擊者來說並不夠。
